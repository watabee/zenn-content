{
  "title": "【Google I/O 2023】Debugging Jetpack Compose",
  "closed": false,
  "archived": false,
  "created_at": "2023-05-25",
  "comments": [
    {
      "author": "watabee",
      "created_at": "2023-05-25",
      "body_markdown": "# Debugging Jetpack Compose\n\nhttps://www.youtube.com/watch?v=Kp-aiSU8qCU&list=PLOU2XLYxmsIIwZQkAPhJZg8jaNrrHk1DH&index=38\n\n\n## Debugging Mindset (0:26~)\n\nデバッグのプロセス。\n\nDefine -> Reproduce -> Validate Assumptions -> Fix\n\n- 何が問題か？\n    - まず最初に解決しようとしている問題が何であるかを定義\n- 問題の再現\n    - 再現可能な例を作る\n- 仮説の検証\n    - 問題を再現して、ツールを使って仮説を検証する\n- 修正する\n\n\n## Commom Compose Issues (1:38~)\n\n### Composable が recompose されていて、どのパラメータが変更されて recompose が発生したかわからない場合\n\n仮説 : recomposition の種類\n\n- Direct recomposition\n- Indirect recomposition\n- Unskippable recomposition\n\n以下は Direct recomposition の例。\n\n```kotlin\n@Composable\nfun DirectRecomposition() {\n    var count by remember { mutableStateOf(1) }\n    Text(\"$count\")\n    Button(onClick = { count++ }) {\n        Text(\"Increment\")\n    }\n}\n```\n\n以下は Indirect recomposition の例。\n\n```kotlin\n@Composable\nfun IndirectRecomposition() {\n    var count by remember { mutableStateOf(0) }\n    val doubled = count * 2\n    \n    MyText(doubled)\n    \n    Button(onClick = { count++ }) {\n        Text(\"Increment\")\n    }\n}\n\n@Composable\nfun MyText(count: Int) {\n    Text(\"$count\")\n}\n```\n\n以下は Indirect recomposition の例。\n\n```kotlin\n@Composable\nfun IndirectRecomposition() {\n    var count by remember { mutableStateOf(0) }\n    val doubled = count * 2\n    \n    MyText(doubled)\n    \n    Button(onClick = { count++ }) {\n        Text(\"Increment\")\n    }\n}\n\n@Composable\nfun MyText(count: Int) {\n    Text(\"$count\")\n}\n```\n\n3番目の例。\nこの例の場合、`count` が変更されると `MyList` は recompose される。\n\n```kotlin\n@Composable\nfun UnstableRecomposition() {\n    var count by remember { mutableStateOf(0) }\n    Text(\"$count\")\n    \n    var list by remember { mutableStateOf(listOf(1, 2, 3)) }\n    MyList(list)\n    \n    Button(onClick = { count++ }) {\n        Text(\"Increment\")\n    }\n}\n\n@Composable\nfun MyList(list: List<Int>) { ... }\n```\n\nAndroid Studio Hedgehog ではデバッガに recomposition state という機能が追加された。\nブレークポイントがヒットすると、Composable の各引数ごとに変更状態を確認できる。\nこの状態は以下のものがある。\n\n- Unchanged : この引数は変更されていない\n- Changed : この引数は異なる値に変更されている\n- Uncertain : Compose はこの引数が変更されたかどうかを評価している\n- Static : Compose はこの引数を変更がないものとみなしている\n- Unstable : 引数は unstable type\n\n4:53~ デモが確認できる。\n\n\n### 頻繁に Recomposition が発生する\n\nスクロールやアニメーションの最中に Composable が recompose される。\n\n```kotlin\n@Composable\nfun ScrollingList() {\n    val listState = rememberLazyListState()\n    LazyRow { ... }\n    \n    Log.d(TAG, \"List recompose ${listState.firstVisibleItemIndex}\")\n    // 値を直接参照せず、ラムダで返すようにする\n    // MyComposable(offset = listState.firstVisibleItemIndex)\n    MyComposable(offset = { listState.firstVisibleItemIndex })\n}\n\n@Composable fun MyComposable(offset: () -> Int) { ... }\n```\n\ngoo.gle/compose-performance を参照。\n\nただし上記の場合、ログで値が直接参照されているのでスクロールした時に引き続き recompose が発生する。\n\nこの場合以下のように `SideEffect` でラップする。\n\n```kotlin\nSideEffect {\n    Log.d(TAG, \"List recompose ${listState.firstVisibleItemIndex}\")\n}\n```\n\n\n### 異なる端末で UI の問題点を知るには？\n\nAndroid Studio Hedgehog では、Compose プレビューの Visual Lint がサポートされた。\n\nレイアウトを複数のスクリーンサイズで確認することができ、何か問題がある場合は Lint が警告かエラーを教えてくれる。\n\n\n## Jank が発生するのはなぜか？ (8:35~)\n\nR8 を有効でかつ baseline profile が設定されたリリースモードで実行して確認する。\n\nLayout Inspector で Recompose が発生した回数が見れるので、回数が多いものがないか確認する。\n\nデバッガで recomposition state を確認する。もし Unstable のものがあった場合、Composable は頻繁に recomposition されている可能性がある。\n=> このような問題を解決するにあたって、まず最初にテストを書いてパフォーマンスを計測する。（Macrobenchmark のライブラリが使える）\n=> Unstable のパラメータが List だった場合、PersistentList に変更してみる。これでリストは Immutable であるとみなされる。\n=> 変更後に再度パフォーマンステストを実行して効果を測定する。\n\n\n### 間違った仮説\n\nPager のアイテムは recomposition をスキップしているという間違った仮説。\n\n- 修正を goo.gle/jetcaster-pager で確認できる\n- ブログ : goo.gle/compose-stability-explained\n- Baseline profiles : goo.gle/baseline-profiles\n\n\n### Summary\n\n- Layout Inspector\n- Macrobenchmark\n    - テストを書いて、修正がパフォーマンス改善を保証することを確認する\n- Debugger\n    - どのパラメータが変わって recomposition を発生させているかを確認できる\n\n\n## どこに最適化の焦点を当てるべきか？ (14:00~)\n\nパフォーマンスモニタリングでフリーズしているフレームがあるようだが、何を修正してよいかがわからない場合。\n\nTracing を使う。\nTracing には2つのタイプがある。\n\n- System trace\n    - オーバーヘッドが少ない\n    - 時間計測に向いている\n    - マークしたイベントのみをトレースできる\n    - 15:27~ デモが見れる\n    - goo.gle/compose-tracing\n- Method trace\n    - オーバーヘッドがある\n    - 全てのメソッドコールが対象\n    - system trace の後に使うのがよい\n    - 15:45~ デモが見れる\n\nAndroid Studio では現在 system trace で Composable 関数を見れるようになった。\n有効にするためには Gradle ファイルに依存関係を設定する。\n\n```groovy\nimplementation(\"androidx.compose.runtime:runtime-tracing:<version>\")\n```\n\n以下は recomposition の system trace の簡単なバージョンの例。\n\n![](https://storage.googleapis.com/zenn-user-upload/ba0f97fa57ff-20230516.png)\n\n各バーはその下にあるバーの合計時間を表している。\nまた、バーは関数呼び出しのスタックトレースに対応している。\nMyImage と MyButton の間が空いているが、system trace はマークされたもののみを表示しているので、これは system trace が追跡できなかったコードが実行されていることを意味する。\n\n17:32 からデモ。\n\n確認したいコードを `trace(\"...\") { ... }` で囲むことによって、system trace に反映される。\n"
    }
  ]
}