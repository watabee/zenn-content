{
  "title": "【Google I/O 2023】Building high quality Android camera experiences",
  "closed": false,
  "archived": false,
  "created_at": "2023-05-25",
  "comments": [
    {
      "author": "watabee",
      "created_at": "2023-05-25",
      "body_markdown": "https://www.youtube.com/watch?v=rNe2xGKjtvc&list=PLOU2XLYxmsIIwZQkAPhJZg8jaNrrHk1DH&index=33\n\n- このセッションで紹介すること\n    - Polished camera previews\n    - Premium visual quality\n    - What else is new on Android 14\n\n\n## Camera Previews (2:05~)\n\n- プレビューの重要性\n    - アスペクト比が合ってなくて歪んだプレビューはプレミアム感が損なわれる\n    - ユーザーはプレビューと実際に保存された写真、動画が合っていることを期待する\n\n### Preview Stabilization (2:52~)\n\n- Android 5 から Video Stabilization がある\n- Android 13 以降の端末は Preview Stabilization が設定できる\n    - カメラプレビューと動画の内容が一致する\n\n![](https://storage.googleapis.com/zenn-user-upload/2cd5be7f9976-20230525.png)\n\nCamera2 で Preview Stabilization を設定するコードは以下。\n\n```kotlin\n// Camera2: When configuring your capture request, check to enable Preview Stabilization.\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun setPreviewStabilization(builder: CaptureRequest.Builder, manager: CameraManager, cameraId: String) {\n    val availableVideoStabilizationModes = manager\n        .getCameraCharacteristics(cameraId)\n        .get(CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES)\n        \n    if (availableVideoStabilizationModes?.contains(CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION) == true) {\n        builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,\n                    CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION)\n    }\n}\n```\n\nCameraX の場合は以下。\n\n```kotlin\n// CameraX: Use Camera2Interop to set the underlying Camera2 CaptureRequest.\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\n@ExperimentalCamera2Interop\nfun setPreviewStabilization(camera: Camera) {\n    val availableVideoStabilizationModes = Camera2CameraInfo.from(camera.cameraInfo)\n        .getCameraCharacteristic(CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES)\n        \n    if (availableVideoStabilizationModes?.contains(CameraMetadata.CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION) == true) {\n        Camera2CameraControl.from(camera.cameraControl).setCaputreRequestOptions(\n            CaptureRequestOptions.Builder().setCaptureRequestOption(\n                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,\n                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION\n            ).build()\n        )\n    }\n}\n```\n\n### Jetpack Preview Classes (4:26~)\n\n- Jetpack には2つのプレビュークラスがある\n    - CameraX : PreviewView\n    - Camera2 CameraViewfinder\n- どちらのプレビュークラスにも6つのスケールタイプが提供されている\n\n![](https://storage.googleapis.com/zenn-user-upload/8a22cdd196c3-20230525.png)\n\nCameraX の PreviewView の設定コードは以下。\n\n```kotlin\n// CameraX: Using PreviewView\nval previewView: PreviewView = viewBinding.viewFinder\ncameraController = LifecycleCameraController(baseContext)\ncameraController.bindToLifecycle(myActivity)\npreviewView.controller = cameraController\n```\n\nCameraX は高度なプレビュー機能も提供している。\n\n```kotlin\n// Add an image analyzer (including our built-in MlKitAnalyzer),\n// with each image's coordinates mapped to the preview.\ncameraController.setImageAnalysisAnalyzer(executor, analyzer)\n\n// Add Graphics Library effects to the preview, images, and video.\ncameraController.setEffects(effects)\n```\n\nCamera2 の場合。\n\n```kotlin\n// Camera2: Using CameraViewFinder\nval previewResolution = Size(width, height)\nval viewfinderSurfaceRequest = SurfaceRequest(previewResolution, characteristics)\nval cameraViewfinder = CameraViewfinder(baseContext)\nval surfaceListenableFuture = cameraViewfinder.requestSurfaceAsync(viewfinderSurfaceRequest)\n\nFuture.addCallback(surfaceListenableFuture,\n                   object: FutureCallback<Surface> {\n    override fun onSuccess(surface: Surface) {\n        // create a CaptureSession using this surface as usual\n    }\n    override fun onFailure(t: Throwable) { /* something went wrong */ }\n}, ContextCompat.getMainExecuter(context))\n```\n\n### Large Screen Previews (8:33~)\n\n- Jetpack のプレビュークラスは大きいスクリーンサイズを考慮している\n\n\n## Premium visual quality (9:41~)\n\n### HDR Video (10:02~)\n\n- Android 13 で HDR のビデオキャプチャが導入された\n    - 10-Bit Color : 1億以上の色が表示できる\n\n10-Bit がサポートされているかのコードは以下。\n\n```kotlin\n// Assure Camera has 10-Bit Capabilities\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun isTenBitSupported(manager: CameraManager, cameraId: String): Boolean {\n    val capabilities = manager\n        .getCameraCharacteristics(cameraId)\n        .get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES)\n        \n    return capabilities?.contains(CameraMetadata.REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT) ?: false\n}\n```\n\nHDR がサポートされているかのコードは以下。\n\n```kotlin\n// Assure Camera supports HLG10\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun isHDRSupported(manager: CameraManager, cameraId: String): Boolean {\n    val supportedProfiles = manager\n        .getCameraCharacteristics(cameraId)\n        .get(CameraCharacteristics.REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES)\n        ?.supportedProfiles\n    \n    return supportedProfiles?.contains(DynamicRangeProfiles.HDR10_PLUS) ?: false\n}\n```\n\nOutputConfiguration の dynamicRangeProfile を設定する。\n\n```kotlin\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun configureSession(device: CameraDevice, targets: List<Surface>, exe: Executor, cb: CameraCaptureSession.StateCallback) {\n    val configs = targets.map {\n        val config = OutputConfiguration(it)\n        config.dynamicRangeProfile = DynamicRangeProfile.HLG10\n        config\n    }\n    \n    val session = SessionConfiguration(\n        SessionConfiguration.SESSION_REGULAR, configs, exe, cb\n    )\n    \n    device.createCaptureSession(session)\n}\n```\n\n最後に MediaFormat を設定する。\n\n```kotlin\n@RequiresApi(Build.VERSION_CODES.N)\nfun configureEncoder(surface: Surface, w: Int, h: Int) {\n    val format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_HEVC, w, h)\n    \n    // Other Setup\n    // ...\n    \n    // Set media format properties\n    format.setInteger(...)\n}\n```\n\nsetInteger の部分には以下のパラメータを設定する。\n\n```kotlin\n/// Color Format\n(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)\n\n/// HEVC (H.265)\n(MediaFormat.KEY_PROFILE, MediaCodecInfo.CodecProfileLevel.HEVCProfileMain10)\n\n/// HLG Color Transfer\n(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_HLG)\n\n/// BT2020 Color Standard\n(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)\n```\n\n### Stream Use Cases (12:23~)\n\n- 以下は事前定義された Stream Use Cases\n    - DEFAULT\n        - 全ての既存の動作をカバーする設定\n    - PREVIEW\n        - Viewfinder やアプリ内の画像解析の用途にオススメ\n    - STILL_CAPTURE\n    - VIDEO_RECORD\n    - VIDEO_CALL\n        - 長時間カメラを使うような電力消費に関わる場合にオススメ\n    - PREVIEW_VIDEO_STILL\n        - ソーシャルメディアアプリや単一の stream use case に推奨される多目的の stream\n    - VENDOR_START\n        - OEM が定義した use cases\n\n13:15 から以下の use case のデモ動画が見れる。\n\n- PREVIEW\n    - Viewfinder としてのパフォーマンスと利便性を最適化\n    - 画像の質は必ずしも最適化されない\n- STILL_CAPTURE\n    - 高品質な画像キャプチャを最適化することが期待される\n    - プレビューのようにフレームレートを維持することは想定されない\n    \n以下は特定の stream use case がサポートされているかどうかをチェックするコード例。   \n\n```kotlin\n// Check if camera supports the stream use case.\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun isStreamUseCaseAvailable(manager: CameraManager, cameraId: String, streamUseCase: Long): Boolean {\n    val characteristics = manager\n        .getCameraCharacteristics(id)\n        .get(CameraCharacteristics.SCALER_AVAILABLE_STREAM_USE_CASES)\n        \n    return characteristics?.contains(streamUseCase) ?: false\n}\n```\n\n以下は stream use case を設定する例。\n\n```kotlin\n// Setup Stream Use Case while setting up your Output Configuration.\n@RequiresApi(Build.VERSION_CODES.TIRAMISU)\nfun configureSession(device: CameraDevice, targets: List<Surface>) {\n    val configs = mutableListOf<OutputConfiguration>()\n    val streamUseCase = CameraMetadata\n        .SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL\n    \n    targets.forEach {\n        val config = OutputConfiguration(it)\n        config.streamUseCase = streamUseCase.toLong()\n        configs.add(config)\n    }\n    ...\n    device.createCaptureSession(session)\n}\n```\n\n### Extensions (13:56~)\n\n- 端末の製造メーカーはカメラの拡張機能を通じて、ナイトモードやボケ効果などの特別な機能を開発者に提供することができる\n- Snapchat はナイトモードの拡張機能で見た目の品質を改善\n- 以下が現在利用できる拡張機能\n    - EXTENSION_NIGHT\n    - EXTENSION_HDR\n    - EXTENSION_AUTO\n    - EXTENSION_BOKEH\n    - EXTENSION_FACE_RETOUCH\n    \n拡張機能がサポートされているかチェックするコードは以下。\n\n```kotlin\n@RequireApi(Build.VERSION_CODE.S)\nfun isExtensionSupported(manager: CameraManager, id: String, extension: Int): Boolean {\n    return manger\n        .getCameraExtensionCharacteristics(id)\n        .supportedExtensions\n        .contains(extension)\n}\n```\n\nボケ効果の拡張機能付きのセッションを作成する例は以下。\n\n```kotlin\n@RequireApi(Build.VERSION_CODE.S)\nprivate fun createCaptureSession(\n    device: CameraDevice,\n    configs: List<OutputConfiguraion>,\n    extension: Int = CameraExtensionCharacteristics.EXTENSION_BOKEH,\n    exe: Executor\n) {\n    if (!isExtensionSupported(manager, device.id, extension)) return\n    \n    // Implement callbacks\n    val cb = object: CameraExtensionSession.StateCallback() {\n        // Implement onConfigured & onConfiguredFailed\n    }\n    \n    val config = ExtensionSessionConfiguration(extension, configs, exe, cb)\n    device.createExtensionSession(config)\n}\n```\n\n---\n\nこれらの機能は CameraX の 1.3.0-alpha から使用可能。\n\n\n## Android 14 (15:50~)\n\n- Ultra HDR still capture\n    - AppCompat で後方互換性のある JPEG フォーマットを設計中\n- P3 color space\n- ズームの最適化\n"
    }
  ]
}