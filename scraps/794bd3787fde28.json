{
  "title": "【Google I/O 2023】Best practices for saving UI state on Android",
  "closed": false,
  "archived": false,
  "created_at": "2023-05-25",
  "comments": [
    {
      "author": "watabee",
      "created_at": "2023-05-25",
      "body_markdown": "# Best practices for saving UI state on Android\nhttps://www.youtube.com/watch?v=V-s4z7B_Gnc&list=PLOU2XLYxmsIIwZQkAPhJZg8jaNrrHk1DH&index=40\n\n## Losing app state (0:41~)\n\nアプリが UI の情報を失う原因。\n\n1. Configuration Changes\n    - 端末の回転、画面のリサイズ、マルチウィンドウモードの切り替え、ライト・ダークモードの切り替えなどの操作\n    - Configuration Changes が起こるとデフォルトでは Activity が再作成され、新しい Configuration で初期化される\n        - マニフェストファイルで Activity の生成を行わないように設定できる\n        - ただしいくつかの Configuration Changes については必ず Activity が再作成される\n    - 詳細は goo.gle/configuration-changes\n2. System needs resources\n    - アプリがバックグラウンドにいる状態でシステムのリソースが枯渇してきた場合、他のアプリのためにシステムはバックグラウンドにいるアプリを終了させることがある\n3. Unexpected app dismissal\n    - ユーザーはアプリの使用履歴の画面でアプリをスワイプすることによって、アプリを強制終了することができる\n\n## Best practices for saving UI state (2:08~)\n\n- Configuration Changes が発生してもデータを保持するためには ViewModel を使う\n    - ViewModel のインスタンスはメモリにキャッシュされている\n    - Navigation ライブラリでは、対象の画面がバックスタックに保持されているときに ViewModel もキャッシュするので、画面を戻った際にもデータがすぐに使える\n    \n以下はコード例。\n\n```kotlin\nclass InterestsViewModel(\n    authorsRepository: AuthorsRepository,\n    topicsRepository: TopicsRepository\n) : ViewModel() {\n    \n    val uiState = combine(\n        authorsRepository.getAuthorsStream(),\n        topicsRepository.getTopicStream()\n    ) { availableAuthors, availableTopics ->\n        InterestsUiState.Interests(availableAuthors, availableTopics)\n    }\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5_000),\n            initialValue = InterestsUiState.Loading\n        )\n}\n```\n\n## Unexpected app dismissal (4:05~)\n\n- 予期しないアプリの終了に対処する場合、情報をメモリではなくストレージに保持しておく\n- ストレージに保持しておくために Jetpack では DataStore と Room が利用可能\n- DataStore\n    - 小さくシンプルなデータセット向き\n- Room\n    - 構造化されたデータ、部分的な更新、参照整合性、巨大で複雑なデータセット向き\n- この方法だと Configuration Changes、System needing resources, Unexpected app dismissal の場合の全てに対処可能\n- I/O 操作が必要になるので読み書きが遅くなる\n    - そのため UI の状態を保持することには普通は使用しない\n    - UI の状態は頻繁に更新されうるので、UI への変更の反映が遅くなってしまう\n\n## System needs resources (5:35~)\n\n- Android では重要なデータを保存しておき、アプリのプロセスが再生成される前の状態に復元するためのメカニズムが提供されている\n- Saved State APIs\n    - 内部では Bundle オブジェクトが使われている\n    - Jetpack Compose、ビューシステム、ViewModel のための API がある\n- この方法だと Configuration Changes、System needing resources の場合に対処可能\n- Android OS がシリアライズされたデータのコピーをアプリのプロセス外のメモリに保持しておく\n- 保存するデータサイズは Bundle によって制限される\n    - 巨大なオブジェクトを保存しようとすると RuntimeException が発生する\n    - 50KB 以上のデータは保存しないことをオススメ\n- シリアライズ、デシリアライズが発生するため、読み書きは遅くなりうる\n- 保存するデータはユーザーの入力やナビゲーションに関する一時的な状態のもの\n    - 例えば、リストのスクロール位置、ユーザーが詳細を知りたいアイテムの ID、ユーザー設定の選択中の状態、テキストフィールドへの入力など\n- Jetpack Compose\n    - `rememberSaveable`\n- ビューシステム\n    - `onSaveInstanceState`\n\nJetpack Compose のコード例。\n\n```kotlin\n@Composable\nfun ChatBubble(\n    message: Message\n) {\n    var showDetails by rememberSaveable { mutableStateOf(false) }\n    \n    ClickableText(\n        text = AnnotatedString(message.content),\n        onClick = { showDetails = !showDetails }\n    )\n    \n    if (showDetails) {\n        Text(message.timestamp)\n    }\n}\n```\n\nビューシステムのコード例。\n\n```kotlin\nclass ChatBubbleView(context: Context, ...) : View(context, ...) {\n    private var isExpanded = false\n    \n    override fun onSaveInstanceState(): Parcelable {\n        super.onSaveInstanceState()\n        return bundleOf(IS_EXPANDED to isExpanded)\n    }\n    \n    override fun onRestoreInstanceState(state: Parcelable) {\n        isExpanded = (state as Bundle).getBoolean(IS_EXPANDED)\n        super.onRestoreInstanceState(null)\n    }\n    \n    companion object {\n        private const val IS_EXPANDED = \"is_expanded\"\n    }\n}\n```\n\n- Testing Saved State APIs\n    - Jetpack Compose\n        - StateRestorationTester\n    - ビューシステム\n        - ActivityScenario.recreate()\n\nJetpack Compose のテストコード例。\n\n```kotlin\nclass ChatBubbleTests {\n    @get:Rule\n    val composeTestRule = createComposeRule()\n    \n    @Test\n    fun onRecreation_stateIsRestored() {\n        val restorationTester = StateRestorationTester(composeTestRule)\n        \n        restorationTester.setContent { ChatBublle() }\n        \n        composeTestRule.onNodeWithText(text = \"Take a look at\", substring = true).performClick()\n        composeTestRule.onNodeWithText(text = \"8:05 PM\").assertIsDisplayed()\n        \n        // Trigger a recreation\n        restorationTester.emulateSavedInstanceStateRestore()\n        \n        composeTestRule.onNodeWithText(text = \"8:05 PM\").assertIsDisplayed()\n    }\n}\n```\n\n- ViewModel integration\n    - SavedStateHandle\n    - goo.gle/architecture-viewmodel-savedstate\n    \nViewModel でのコード例。\n\n```kotlin\nclass ConversationViewModel(\n    savedStateHandle: SavedStateHandle\n) : ViewModel() {\n    \n    // SavedStateHandle は Activity が STOP 状態になった時のみデータを保存する\n    var message by savedStateHandle.saveable(stateSaver = TextFieldValue.Saver) {\n        mutableStateOf(TextFieldValue(\"\"))\n    }\n        private set\n    \n    fun update(newMessage: TextFieldValue) {\n        message = newMessage\n    }\n    \n    fun send() { /* Send current message to the data layer */ }\n}\n```\n\n## Under the hood and advanced use cases (10:42~)\n\n### Contribute to saved state from your own classes\n\nニュースのための再利用可能な検索 UI があり、ユーザーが検索のために入力したテキストを saved state に保存したい場合を考える。\nCompose での State Holder は以下のようになる。\n\n```kotlin\nclass NewsSearchState(\n    private val newsRepository: NewsRepository,\n    initialSearchInput: String\n) {\n    var searchInput = mutableStateOf(TextFieldValue(initialSearchInput))\n        private set\n    \n    companion object {\n        fun saver(newsRepository: NewsRepository): Saver<NewsSearchState, *> = Saver(\n            save = {\n                with(TextFieldValue.Saver) { save(it.searchInput) }\n            },\n            restore = {\n                TextFieldValue.Saver.restore(it)?.let { searchInput -> \n                    NewsSearchState(newsRepository, searchInput)\n                }\n            }\n        )\n    }\n}\n```\n\nCompose で状態を saved state にするには、rememberSaveable を使う。\n\n```kotlin\n@Composable\nfun rememberNewsSearchState(\n    newsRepository: NewsRepository,\n    initialSearchInput: String = \"\"\n) {\n    return rememberSaveable(\n        newsRepository, initialSearchInput,\n        saver = NewsSearchState.saver(newsRepository)\n    ) {\n        NewsSearchState(newsRepository, initialSearchInput)\n    }\n}\n```\n\nビューシステムで同じように実装するには SavedStateRegistry を使う。\n\n```kotlin\nclass NewsSearchState(\n    private val newsRepository: NewsRepository,\n    private val initialSearchInput: String.\n    registryOwner: SavedStateRegistryOwner\n) : SavedStateRegistry.SavedStateProvider {\n    \n    private var currentQuery: String = initialSearchInput\n    \n    init {\n        registryOwner.lifecycle.addObserver(LifecycleEventObserver { _, event -> \n            if (event == Lifecycle.Event.ON_CREATE) {\n                val registry = registryOwner.savedStateRegistry\n                if (registry.getSavedStateProvider(PROVIDER) == null) {\n                    registry.registerSavedStateProvider(PROVIDER, this)\n                }\n                val savedState = registry.consumeRestoredStateForKey(PROVIDER)\n                currentQuery = savedState?.getString(QUERY) ?: initialSearchInput\n            }\n        })\n    }\n    \n    // ... Rest of business logic ...\n    \n    override fun saveState(): Bundle {\n        return bundleOf(QUERY to currentQuery)\n    }\n    \n    companion object {\n        private const val QUERY = \"current_query\"\n        private const val PROVIDER = \"news_search_state\"\n    }\n}\n```\n\nFragment で使う場合は以下のように初期化する。\n\n```kotlin\nclass NewsFragment : Fragment() {\n    \n    private var newsSearchState = NewsSearchState(this)\n    ...\n}\n```\n\n### Control rememberSaveable value's lifecycle\n\nJetpack Compose では `SaveableStateRegistry` でコンポーネントの状態を保存、復元する。\n以下は rememberSaveable のコード。\n\n```kotlin\n@Composable\nfun <T : Any> rememberSaveable(\n    vararg inputs: Any?,\n    saver: Saver<T, out Any> = autoSaver(),\n    key: String? = null,\n    init: () -> T\n): T {\n    // ...\n    \n    val registry = LocalSaveableStateRegistry.current\n    val value = remember(*inputs) {\n        val restored = registry?.consumeRestored(finalKey)?.let {\n            saver.restore(it)\n        }\n        restored ?: init()\n    }\n\n```\n\n新しい `SaveableStateRegistry` を定義することにより、`rememberSaveable` が値を保持する期間を制御できる。\nこれは Navigation ライブラリでも行なっていて、Navigation ではバックスタックにいる間は `rememberSaveable` の値がレジストリに保持される。\n\n```kotlin\n@Composable\npublic fun NavHost(...) {\n    // ...\n    val saveableStateHolder = rememberSaveableStateHolder()\n    // ...\n    \n    backStackEntry?.LocalOwnersProvider(saveableStateHolder) {\n        content(backstackEntry)\n    }\n    // ...\n}\n```\n\n```kotlin\n@Composable\npublic fun NavBackStackEntry.LocalOwnersProvider(\n    saveableStateHolder: SaveableStateHolder,\n    content: @Composable () -> Unit\n) {\n    CompositionLocalProvider(\n        LocalViewModelStoreOwner provides this,\n        LocalLifecycleOwner provides this,\n        LocalSavedStateRegistryOwner provides this\n    ) {\n        saveableStateHolder.SaveableStateProvider(content)\n    }\n}\n```\n\n## Recap (19:00~)\n\n| | Survives | Limited by | Use for |\n| ------- | ------- | ------- | ------- |\n| ViewModel | Configuration changes | Available memory | UI state |\n| Saved State APIs | Above + system needing resources | Bundle | Transient UI state that depends on user input or navigation |\n| Persistent Storage | Above + unexpected app dismissals | Disk space | Application data |\n\n"
    }
  ]
}